---
title: "International Food Security"
author: "Scott Braley"
date: "October 4, 2016"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r loading_libraries}
library(tidyverse)
library(knitr)
library(ggthemes)
```

## About the data

[Data.gov](https://www.data.gov) bills itself as "the home of the U.S. Government's open data." One of the many data sources publicly available from this site is a data set from The Economic Research Service (ERS) of the U.S. Department of Agriculture titled "International Food Security."  

The data set was used to produce the ERS International Food Security Assessment 2013-2023 report and was released in June 2013. (Documentation for the most recent 2015-2025 report, which is still helpful for this past data set, can be found [here](http://www.ers.usda.gov/data-products/international-food-security/documentation.aspx)).  

You can download the CSV data file from [this webpage](https://catalog.data.gov/dataset/international-food-security). The file name should be "gfa25.csv" when you download this file; keep this file name, or rename the file to "gfa25.csv" if it was downloaded with a different file name.  

```{r read_first_data_file}
## error on attempting to load from website 
## in this mkdown file downloaded manually and placed in wd
gfa25 <- read_csv("gfa25.csv")
```

The food security data set has annual time series data for several variables (we'll focus on just a few, including GDP, food aid, and population). However, it's missing another variable we'd like: land area. The [World Bank Open Data](http://data.worldbank.org/) site has land area data (in square kilometers) available to download [here](http://data.worldbank.org/indicator/AG.LND.TOTL.K2?name_desc=false). Download this data, and rename the file with the country-specific data as "worldbank_landarea.csv". Of the files included with the download from the World Bank site, this is the only file that is not metadata.  

```{r download_land_area}
## had to download and rename manually due to zip file.  
## Placed into working directory.
wb_land_area <- read_csv("worldbank_landarea.csv", skip = 4)
```

We'll read in and clean up both data sets separately before joining them together.  

## Food security

To begin, read in and clean the International Food Security data set. The raw data looks like this:  

```{r head_of_gfa25}
head(gfa25,3)
```

We are interested in data on each country's total food aid (Grain Equivalent, 1000 MT), the country's total population, and the country's gross domestic product (in 2005 dollars). Currently, these three variables are listed within the column "Item" (values "Total", "Total Population - Both Sexes", and "GDP (constant 2005 US$)"), with observed values in the "Amount" column.  

We need to clean this data up to make it easier to use for plotting and analysis. First, filter the data, so that it only includes rows where the value of "Item" is one of the three variables of interest.  

```{r filter_gfa25}
gfa25 <- filter(gfa25, 
                Item == "Total" | Item == "Total Population - Both Sexes" |  Item == "GDP (constant 2005 US$)")
```

Next, the columns "Commodity" and "Unit" seem to be constant for a given value of "Item". Therefore, we'll make a separate dataframe called ```meta_food``` that has columns for "Item", "Commodity", and "Unit". It should include only columns for "Item", "Commodity", and "Unite", and give only the unique rows. (Hint: The ```distinct``` function from ```dplyr``` is useful for this step.)

```{r create_meta_food}
# note that meta_food is never used subsequently
(meta_food <- distinct(select(gfa25,Item, Commodity, Unit)))
```

Now that we have saved this information in a separate data set, we'll clean up the main dataframe (food). First, we remove the columns for "Commodity" and "Unit", then we convert the data set so that "Total", "Total Population - Both Sexes", and "GDP (constant 2005 US$)" are each separate columns, with the values given in "Amount" as the cell values. Finally, rename the variables "Country" and "Year" to be lowercase and use the column names "food_aid" for "Total", "pop" for "Total Population - Both Sexes", and "gdp" for "GDP (constant 2005 US$)". After these changes, the first ten rows of the dataframe look like this:

```{r cleanup_gfa25}
gfa25 <- gfa25 %>%
  select(-Commodity, -Unit) %>%
  spread(key = Item, value = Amount) %>%
  rename(country = Country, year = Year, gdp = `GDP (constant 2005 US$)`, 
                food_aid = Total, pop = `Total Population - Both Sexes`)
head(gfa25, 10)
```


## Land area

Next, we can add another variable to our data set (land area) that exists in a separate data set. We'll download and read in the World Bank's land area data. Here are the column names of the raw data:

```{r cols_in_land_area_raw}
variable.names(wb_land_area)
```

We are not going to use the column named "Country Code", and the columns "Indicator Name" and "Indicator Code" are always the same (you can use unique to confirm this if you'd like). Therefore, we'll clean this data by removing these three columns. Next, we'll rename "Country Name" to "country". Next, a variable ("year") is currently in the column names ("1960", "1961", etc.). We will convert the dataframe to bring the year into a column named "year" and the observed value for each of these years into a column called "land_area". Then, we'll filter out any rows with missing data for "land_area". Finally, we'll change the class of "year" to integer class (check out ```as.integer``` for this step) and the class of "land_area" to numeric. After this cleaning, the first ten rows of the dataframe look like this:

```{r cleanup_land_area}
wb_land_area <- wb_land_area %>%
  select(-`Country Code`, -`Indicator Name`, 
         -`Indicator Code`, -`2016`, -X62) %>%
  rename(country = `Country Name`) %>%
  gather(key = year, value = land_area, -country) %>%
  na.omit()

wb_land_area$year <- as.integer(wb_land_area$year)
wb_land_area$land_area <- as.numeric(wb_land_area$land_area)
head(wb_land_area, 10)
```

## Join the dataframes
Now that both dataframes are cleaned up, we can join them together by ```country``` and ```year```. Since we're only interested in countries that have both land_area **and** food security data available, we'll do an ```inner_join```. The first six rows of our joined dataframe should look like this:

```{r join_dataframes}
food_land <- inner_join(wb_land_area, gfa25)
head(food_land, 6)
```

## Summary of GDP

The following table shows the average, minimum, and maximum values of GDP between 2000 and 2009 (inclusive) for each the ten countries with highest mean GDP over this time period. (Hint: Set ```na.rm = FALSE```, or leave this as the default, in calculating all these functions, so the final table will only include countries with complete data from 2000 to 2009.)

```{r gdp_summary}
temp_data <- subset(food_land, year > 1999 & year < 2010) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp),
            min_gdp = min(gdp),
            max_gdp = max(gdp)) %>%
  arrange(desc(mean_gdp))
top_ten <- temp_data[1:10,]
kable(top_ten, col.names = c("Country", "GDP (mean)", "GDP (minimum)", "GDP (maximum)"))
```

## Visualization

The following plot shows the association between land area and population for the year 2013 for countries in this data set. Countries with unusual values (India, Bangladesh, Jamaica, Swaziland, Mongolia, and Namibia) are highlighted. (Hint: Use these country names to do the subsetting necessary to create this highlighting. To make sure the labels aren't directly over the points, use the ```vjust = "outward"``` and ```hjust = "inward"``` arguments).  

```{r plot_pop_land}
pop_land <- subset(food_land, year == 2013)
outliers <- subset(pop_land, 
                   country %in% c("Swaziland", "Jamaica", "Namibia", 
                                "Mongolia", "Bangladesh", "India"))
ggplot(pop_land, aes(x = land_area, y = pop)) +
  geom_point(size = 0.5, alpha = 0.5) +
  geom_text(data = outliers, 
            aes(label = country), color = "black", 
            size = 3, vjust = "outward", hjust = "inward") +
  geom_point(data = outliers, size = .7, color = "red") +
  scale_x_log10() +
  scale_y_log10() +
  theme_few(base_size = 10) +
  xlab("Land Area (square km)") +
  ylab("Population (millions)")
```

The next figure shows the total food aid received by the countries in this data set in 2010. Note that the points in this plot are arranging by total food aid in 2010. (Hint: Adjust the ```fig.height``` option in your code chunk so that the country labels are readable in the rendered figure.)

```{r food_aid, fig.height= 7}
food_aid_2010 <- subset(food_land, year == 2010)
food_aid_2010$country <- factor(food_aid_2010$country, levels =
  food_aid_2010$country[order(food_aid_2010$food_aid)])
ggplot(food_aid_2010, aes(x = food_aid, y = country)) +
  geom_point() +
  theme_few(base_size = 10) +
  xlab("Food aid (grain equivalent, 1000 metric tons)") +
  ylab(NULL)
```

 
## Plotting function

Finally, we've written a function called ```plot_pop``` that will plot population over time for a selected country. It has two arguments, ```datafr``` and ```which_country```. If you run the function, it will subset data for a single country from the dataframe specified with ```datafr``` and will plot year versus population for that country. For example, running ```plot_pop(datafr = food_land, which_country = "India")``` would plot population over time in India:

```{r function_plot_pop}
pop_plot <- function(datafr, which_country) {
  country_info <- subset(datafr, country == which_country)
  ggplot(country_info, aes(x = year, y = pop)) +
    geom_line() +
    xlab("Year") +
    ylab("Population (millions)") +
    ggtitle(paste("Population in", which_country)) 
}
```

```{r sample_india}
pop_plot(datafr = food_land, which_country = "India")
```

(Hint: Look closely at the plot and make sure your function creates a plot that looks the same, in terms of elements like axis labels and the plot title. Also, you can assume that ```datafr```, the dataframe input to the function, always has a column named ```country``` with countries and a column named ```pop``` with yearly population. You can also assume that the country name input for ```which_country``` is always a country that has data in the dataframe, so you don't need to include any code for error checking.)
Here are a few more examples of running this function:

```{r sample_jamaica, fig.height = 2, fig.width = 3}
pop_plot(datafr = food_land, which_country = "Jamaica")
```
 
```{r sample_angola, fig.height = 2, fig.width = 3}
pop_plot(datafr = food_land, which_country = "Angola")
```
